[면접문제 1 - 자료형  p.49]

		method 명 변수명은 소문자로 시작(cf.클래스명은 대문자로 시작)		
		 변수 :  데이터를 담는 그릇이며, 데이터의 저장과 참조를 위해 메모리 공간을 할당받는다.
		        반드시 먼저 선언 : 컴파일러는 변수의 자료형에 맞는  기억공간을 미리 확보
		        선언 : 자료형 변수명 ; 예) int age ;
		        선언과 동시에 할당 :자료형  변수명= 초기화; 예) int age = 30;
		          
[면접문제 2- ]
		  1. 기본 자료형 (Primitive Type) : 실제 값 저장 
		   정수형 :  byte  (1바이트) -> short  (2바이트) -> int (4바이트) -> long (8바이트)
		   실수형 :  float (4바이트) -> double (8바이트)
		   문자형 :  char  (2바이트)
		   부울형 :  boolean (true/false) 
		 
		  2. 참조형 (Reference Type) : 실제 객체를 가르키는 주소 값 저장
		 		클래스, 인터페이스,배열 
		  
		 
		 3. 문자열 : String 클래스 
		 
	
[면접문제 3 - 상수  p.62]	
		
	상수 : 프로그램이 실행되는 동안, 값이 변하지  않는 수 또는 변경 불가능한 수
		 final 키워드는 변수에 값이 대입되고  나면, 변수값이 더 이상 변경되지 않는다는 의미 
		  주로 대문자를 사용
		  만일 값 변경시 상수를 선언한 부분의 값만 변경    final double PI = 3.14; // 상수 선언 및 초기화	 
		  	- final 선언이유는 모든 하위클래스가 공통으로 사용하고, 코드를 변경하면 안되기때문에 final로 선언함
			- final 메소드명 : 상속받은 하위클래스가 부모 메소드를 재정의 할 수 없음 (305page)
		  
		  
[면접문제 4 -오버로드]
오버로드 vs 오버라이딩
오버로드     : 메소드나 생성자의 매개변수가 다르거나, 매개변수 타입이 다른경우(단, 리턴 타입은 무관)		  
오버라이딩  : 상속받은 자식 클래스가  부모 메소드를 재정의(메소드명이 똑같음, Override시 다형성 적용시 자식 메소드 실행이 됨)		  
		  
[면접-5 상속]
    상속의 의미  : 자식클래스 extends 부모클래스	{  ...  } 
  - extends : 확장(파생의 의미)
  - 공통으로 사용하는 멤버변수와 멤버메서드를 부모클래스에서 정의 
  - 부모클래스는 일반적이고 공통이며, 자식클래스는 구체적, 유일하다.
  	  
  - 상속 사용이유 : 부모클래스의 멤버변수와 멤버메소드를 재사용 ==> 중복되는 코드제거 		
                                  유지보수 용이, 중복된 코드(공통 코드) 를 줄임으로써 손쉽게 개발
  
  - 부모클래스의 멤버를 private으로 선언한 경우, 자식클래스에서 접근할 수 없다.
  	접근제어자 protected의 경우 자식클래스에서 접근이 가능하다. 
  		
  			
[면접 - 6 오버라이딩]

@Override -자식 클래스에서 부모  메소드 재정의 (자식클래스 필요대로 수정가능)
		     자식클래스의 메소드가 부모클래스의 메소드를 오버라이드(재정의) 한다라고 한다.
		     상속에서 부모클래스의 메소드를 변경하고자 할 때 사용한다
		     상속해서 자식 클래스에서 부모클래스를 변경하고자 할 때 사용
		     메소드의 이름, 매개변수, 매개변수 자료형, 반환형까지 모두 동일해야한다.
		  (동일하지 않으면 컴파일러가 다른 메서드로 인식)
		    호출시 오버라이딩 한 자식 메소드가 호출됨
		     오버라이드의 목적은 부모클래스의 메소드를 변경해서 자식쪽에서 호출하고자 하는 의도
		     오버로드랑 오버라이딩 구분 잘 하기 
			super - 부모의 참조변수
		    super  :  하위클래스에서 상위클래스로 접근할 때 사용
		    하위클래스는 상위클래스의 주소,  즉 참조값을 알고 있다.
		    상위클래스의 생성자를 호출할때도 사용
		 	ex) super( );  
		 
		  this : 자기 자신의 주소값
		    부모 메소드명과 자식 메소드명이 똑같으므로 재정의(부모의 메소드를  재정의)
		  					
   [면접 -7 싱글톤패턴]
  		싱글톤패턴
   -  인스턴스를 단 하나만 생성하는 디자인패턴
   -  static을 응용해서 프로그램 전반에서 사용하는 동일한 인스턴스를 하나만 생성하
           는 방식
           
   -  접근할 클래스에서 여러 메소드가 있을때, 외부 클래스가 해당 메소드에 접근할 때마다 객체를 생성 할 필요없이 
  	    한번만 getInstance() 통해서 참조변수만 리턴받아 접근한다.
       
       싱글톤 패턴 생성
       - 1단계 : 생성자를 private으로 만들기
       - 2단계 : 클래스 내부에 static으로 유일한 인스턴스 생성하기
       - 3단계 : 외부에서 참조할 수 있는 public 메소드 만들기
   
        호출 방법
         외부클래스명 참조변수  =  외부클래스명.getInstance( );
         예) _08_Company com1 =_08_Company.getInstace( );
         
         주소값은 다 똑같음 
       call by value : 메서드 호출 시 매개변수에 값 전달
 	   call by reference : 메서드 호출 시 매개변수에 주소(참조값)전달


   [면접 8]	
   
추상클래스 VS  인터페이스
 - 기능정의서 (표준 작업명세서) >강제성과 통일성
 - 설계(선언)와 구현을 분리시키는 것을 가능하게 한다.
 		(설계 : 인터페이스, 구현 : 자식클래스)
 - 객체생성 불가능하며,객체 Type으로는 가능(다형성 적용시 Type으로 가능)
 - 인터페이스의 멤버는 상수(static final 생략가능) , 추상메소드(abstract 생략가능)만 올 수 있다.
 - 단 static 메소드, default 메소드,  private 메소드는 예외(JDK 1.8부터)
 - 인터페이스를 implements (=구현)할 자식클래스에서 추상메소드를 재정의한다.
 	
 1. 인터페이스 작성
   interface 인터페이스명 {
  	// 상수
 	public static final 데이터타입 대문자 상수명 = 값;
  	
  	//추상 메소드
 	public 반환형 추상메소드 ( 매개변수...... ) ; 바디가 없다.중괄호가 없음
  	
  	2. 인터페이스  구현
 	class 클래스명 implements 인터페이스명 ==> extends는 안됨 같은 인터페이스끼리만 가능
  	@Override	
  	public 반환형 추상메소드(매개변수  ........){
  	인터페이스에 정의된 추상메소드를 구현해야한다(재정의)
  	}
  	
 	3. 인터페이스 다중상속 가능 
 	interface 인터페이스명 extends 인터페이스명1, 인터페이스명2 .... 여러개가능{	
 
 	}
  
 	class 클래스명 extends 클래스명1, ..... 클래스명 n {  ==> 불가함 클래스는 단일 상속만 가능
 
 	}
 
  	4. 상속과 구현을 동시
  	class 클래스명 extends 부모클래스 implements 인터페이스명1...인터페이스명2.....여러개가능
  	
  	}	
			  		
			  	
[면접 9 - ArrayList]
 컬렉션 프레임 워크
  		
 Collection 인터페이스 
 - List 인터페이스 : 클래스는 ArrayList, Vector, LinkedList
 - set 인터페이스 :클래스는 HashSet,TreeSet
  
Map 인터페이스 : 클래스 (HashMap, HashTable, TreeMap)


[면접 10] 
1.특징
List 인터페이스 : 순서가 있는 자료관리, 값 중복허용한다.
  			   index를 사용해서 요소에 접근한다.
  			     리스트에 들어있는 요소들의 인덱스는 0부터 시작한다.
  			     클래스는 ArrayList, Vector, LinkedList
  			
Set 인터페이스 : 순서가 없는 자료관리, 중복허용 않는다.
  		           클래스종류는 Hashset, TreeSet
  		
[ArrayList]
2.선언  
ArrayList <데이터타입클래스> 변수명 =new ArrayList<데이터타입클래스>();
 
		    다형성 적용 //부모가 List   //자식이 ArrayList
List <데이터타입클래스> 변수명 = new ArrayList<데이터타입클래스>();
 
3. 특징 : 데이터 순서가 있고, 중복허용된다.
 
4. 추가 : 참조변수명.add(값 ); 추가는 add
 		       참조변수명.add(추가할 위치 index,값); //지정한 인덱스에 값을 추가, 그 뒤 값은 밀려난다.
 		   
5. 값 가져오기 : list.get(가져올 index);   //list.size() 만큼 반복	
    
6. 교체 : list.set(교체할 위치 index, 값);  //지정한 index에 값을 변경한다....그 뒤 값은 그대로다
7. list.remove(삭제할 위치 index, 값);   
8. 검색 : list.indexOf(검색할 값);  //중요
    	리스트에서 검색할 값과 똑같은 값을 갖는 첫번째 데이터를 찾아서  그 위치의 인데스를 리턴 	 	
 			검색할 값과 일치한 데이터가없으면 -1을 리턴한다
9.전체 삭제 : list.clear();
  	
10.반복자 : Iterator <E> iterator : while(hasNext() ){ next() }
. 
 	
 
					 
					 
					 		  	
			  
[면접 11 - HashMap]		  				
		
[면접 page 439]
해싱(hashing) : 키를 이용해서 해시테이블로부터 데이터를 가져오는 과정 	

HashMap
1) 특징
-  데이터의 순서를 보장하지 않는다.
-  key 와 value 쌍으로 저장한다.
-  key는중복되면 안된다.
-  key를 이용해서  value를 가지고온다.
- List 계열과 달리 index가 없다.
- Map 이라는 인터페이스를 구현한 클래스이다. 

2) 선언
- HashMap <Key 타입, value 타입> map = new HashMap <key타입, value 타입> ();
- Map<Key 타입, value 타입> map = new HashMap <key타이브 value타입>(); //  다형성 적용

3) 메소드
- 데이터 추가 :  put(key , value);
- 데이터 삭제 : remove(key)
- 데이터가 비어있는지 여부 : isEmpty();
- 해당 키가 있는지여부  : containsKey();
- 해당 값이 있는지 여부 : contatinsValue(value)
- 해당개수 :  size()
  
				
[면접 12]	
	
  제네릭 : 여러 참조 자료형이 쓰일 수 있는 곳에 특정한 자료형을 지정하지않고
  		클래스나 메소드를 지정한 후 사용하는 시점 (제네릭 클래스의 인스턴스 생성시점)에
               어떤 자료형을 사용할 것인지 지정하는 방식
  			T : type           K : Key
  			E : element        V : value
 		
  	 -  제네릭으로 구현하면 형변환을 하지 않아도된다.(매개변수의 다형성, 다운캐스팅 ==> 안해도 된다.)
 	 => 제네릭 클래스를 사용하면 컴파일러는 일단 대입된 자료형이 잘 쓰였는지 확인한다.
  	    class 파일을 생성할 때 T를 사용한 곳에 지정된 자료형에 따라서 컴파일한다.
  	 
  	    
 [면접]
  예외 처리 목적 : 예외가 발생하더라도 정상종료 목적
  
 try {
   	 예외가 발생할 수 있는 코드 부분
  } catch(처리할 예외타입 e) {
  	 try 블록안에서 예외가 발생했을 때 예외를 처리하는 부분 	
  } finally {  ==> 반드시 수행됨 
  	 예외가 발생하지 않으면 catch문은 수행되지 않지만 finally문은 항상 수행되는 부분.
   	 주로 자원해제를 위한 close(); 문장이 온다.	  
  } 	    
  
  
  
  [면접] 
 Thread 생성과 실행
   (2) Runnable 인터페이스를 구현하는 방법
  	1. Runnable 인터페이스를 implements 받아 클래스를 작성 
    2. 추상메소드 run() 메서드를 재정의 한다. 
  	3. main ()에서 thread 객체를 생성하고, 이 때 implements 받은 클래스 객체를 매개변수로 전달한다.
  	4. start() 메소드를 호출하여 thread 를  실행한다.
  	5. run() 메소드가 실행된다.	


 	멀티태스킹 : 여러개의 어플리케이션을 동시에 실행해서 컴퓨터 시스템의 성능을 높이기 위한 기법  
	 			 테스크 : 하나의 업무 처리 단위 				
	 
				예) 음악을 들으면서 동시에 운동
	  			       문서를 편집하면서 인터넷에서 파일 다운로드
	  			
	  멀티쓰레딩 : 병렬작업을 하나의 어플리케이션 안에서 동시에 하는것을 말한다. 
	      
	  쓰레드 : 각각의 작업 ...실....실행흐름    	
	  
	  	멀티스레딩의 장점 
	  	1) CPU의 사용률을 향상시킨다.
	  	2) 자원을 보다 효율적으로 사용할 수 있다.
	  	3) 사용자에 대한 응답성이 향상된다.
	  	4) 작업이 분리되어서 코드가 간결
	  
	  
	  Thread 문법  
	  1)Thread 클래스를 상속하기 -> run() 메소드 오버라이드 
	  2)Runnable 인터페이스를 구현하는 방법  -> run ()메소드 오버라이드
	  
	  
SQL [면접]
Equi Join  : 매우중요
- 조인 대상 테이블에서 공통 컬럼을 '='(equal) 비교를 통해서 같은 값을 가지는 행을 연결

1. 정의 : 가장 많이 사용되는 조인방법으로, 조인 대상이 되는 두 테이블에서 공통적으로
          존재하는 컬럼의 값이 일치하는 행을 연결하여 검색결과를 생성하는 방법
 - FROM  절은 조인 대상 테이블을 기술하고, 테이블은 콤마( , ) 로 구분한다.
 - WHERE 절은 조인을 위한 컬럼명과 '=' 연산자를 사용하여 조인조건을 기술한다
 - 조건에 사용되는 컬럼은 일반적으로 기본키와 외래키에 공통적으로 존재하는 컬러명을 사용
 
 - 기본키 (PK : Primary Key) : 중복되지 않아야하며 NOT NULL 이여야 한다
 - 외래키 (FK : Foreign Key) : 다른 테이블의 기본키를 참조하며, 반드시 NOT NULL 은 아니다.
  예) 기본키 : 부서테이블.부서ID               외래키 : 사원테이블.부서ID
      부모테이블 : 부서테이블                  자식테이블 : 사원테이블
      
2. 중복컬럼(모호한 컬럼)일 경우에는 컬럼명앞에 테이블명 (또는 별칭)을 기술하여 어느 테이블 소속인지
   구분한다.
	 
	 	 
					
					